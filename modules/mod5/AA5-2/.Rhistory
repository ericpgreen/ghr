library(multiwayvcov)
library(sandwich)
robustse.f <- function(model, cluster, df_correction) {
## Huber-White heteroskedasticity-robust standard error calculation and table generation code for lm and glm models in R.
##Written by Joshua Gubler ~  http://joshuagubler.com.  Note that the second half of this function is just a wrapper for the excellent "multiwaycov" package here: https://cran.r-project.org/web/packages/multiwayvcov/multiwayvcov.pdf .  Love the authors of that package...
##Last updated: 3 November 2016
#model = the model you estimated, now calculated with robust standard errors
#cluster = the name of the entity on which you will cluster (need to put full path: e.f. df$cluster).  If you don't put in a cluster, you will simply get huber-white robust errors.
#df_correction: If you do not want the number of levels in your cluster variable to count against your degrees of freedom (like the xt- options in Stata), then type "F".  Otherwise, type "T" and these levels will be counted against your degrees of freedom
require(sandwich)
require(lmtest)
require(multiwayvcov)
if(missing(cluster)) {
name <- deparse(substitute(model))
modelname <- paste(name,"rob",sep=".")
model$se <- coeftest(model, vcov=vcovHC(model,"HC1"))[,2]
model$vcovHC <- vcovHC(model,"HC1")
assign(modelname,model,envir = .GlobalEnv)
coeftest(model, vcov=vcovHC(model,"HC1"))
} else {
name <- deparse(substitute(model))
modelname <- paste(name,"rob",sep=".")
vcovCL <- cluster.vcov(model, cluster, df_correction = df_correction)
model$vcovCL <- vcovCL
modelname <- paste(name,"clustrob",sep=".")
model$se <- coeftest(model, vcovCL)[,2]
assign(modelname,model,envir = .GlobalEnv)
coeftest(model, vcovCL)
}
}
# survey data
load("input/survey/dat-Puffer2011.RData")
load("input/survey/dat-Parent.RData")
# interview data
path <- "input/spatial/shapefiles/interviews/edited/Complete"
# list all folders
youth <- list.dirs(path)
# muhuru shapfiles
map <- readShapePoly("input/spatial/shapefiles/basemap/MB_Locations.shp")
proj4string(map) <-  CRS("+init=epsg:32736") # UTM36S
map <- spTransform(map, CRS("+proj=longlat +ellps=WGS84"))
red <- readShapePoints("input/spatial/shapefiles/dot maps/red.shp")
proj4string(red) <-  CRS("+init=epsg:32736") # UTM36S
red <- spTransform(red, CRS("+proj=longlat +ellps=WGS84"))
#plot(map)
#plot(red, add=T)
# focus group dot maps
#   . tab group
#
#          group |      Freq.     Percent        Cum.
# ---------------+-----------------------------------
#         chiefs |        164       11.94       11.94
# health workers |         68        4.95       16.89
#  women leaders |         90        6.55       23.44
#       Nyakondo |        240       17.47       40.90
#      Nyangwayo |        276       20.09       60.99
#          Senye |        276       20.09       81.08
#          Winjo |        260       18.92      100.00
# ---------------+-----------------------------------
#          Total |      1,374      100.00
#
# . tab type
#
#  10^1 digit of |
#            pid |      Freq.     Percent        Cum.
# ---------------+-----------------------------------
#        parents |        387       28.17       28.17
#       teachers |        281       20.45       48.62
#         youths |        384       27.95       76.56
#         chiefs |        164       11.94       88.50
# health workers |         68        4.95       93.45
#  women leaders |         90        6.55      100.00
# ---------------+-----------------------------------
#          Total |      1,374      100.00
dat$motherliving <- ifelse(dat$motherliving=="yes", 1, 0)
dat$motherinhome[dat$motherinhome==998] <- NA
dat$fatherliving <- ifelse(dat$fatherliving=="yes", 1, 0)
dat$fatherinhome[dat$fatherinhome==998] <- NA
dat$vagsexever <- ifelse(dat$vagsexever=="yes", 1, 0)
dat$agefirstvagsex[dat$agefirstvagsex==998] <- NA
dat$oralsexever <- ifelse(dat$oralsexever=="yes", 1, 0)
dat$condomlastsex <- ifelse(dat$condomlastsex=="yes", 1, 0)
# give a risk score to everyone and then indicate who was high risk
dat$highRisk <- 0
dat$highRisk[dat$RiskIndex=="high risk sex (no condom or multiple partners)"] <- 1
# perceived
dat$perRiskHigh <- 0
dat$perRiskHigh[dat$perchivrisk=="i have quite a lot of chance of getting hiv" |
dat$perchivrisk=="i will probably get hiv"] <- 1
dat$yfemale <- ifelse(dat$ygender=="female", 1, 0)
View(dat)
cor(dat$selfesteemsum, dat$partners12mths)
cor(dat$selfesteemsum, dat$yselfeffsum)
cor(dat$selfesteemsum, dat$yselfeffsum, na.rm=T)
cor(dat$selfesteemsum, dat$yselfeffsum, na.action='use.complete')
?cor
cor(dat$selfesteemsum, dat$yselfeffsum, use="complete.obs")
sum(is.na(dat$yselfeffsum))
cor(dat$selfesteemsum, dat$vagsexever, use="complete.obs")
sum(is.na(dat$vagsexever))
cor(dat$selfesteemsum, dat$condomlastsex, use="complete.obs")
sum(is.na(dat$condomlastsex))
325-214
table(dat$vagsexever)
library(foreign)
dat <- read.spss("/Users/ericgreen/Desktop/Youth Data 10-29-09_Syntax run.sav",
to.data.frame = T)
library(foreign)
dat <- read.spss("/Users/ericgreen/Desktop/Youth Data 10-29-09_Syntax run.sav",
to.data.frame = T)
dat$females12mths
dat$males12mths
dat$partners12mths <- dat$males12mths+dat$females12mths
dat$partners12mths
cor(dat$selfesteemsum, dat$partners12mths, use="complete.obs")
library(arm)
set.seed(1)
df <- data.frame(y=runif(50),
x1=runif(50),
x2=runif(50))
# does not work
for (i in c("x1", "x2")) {
#f <- paste("y", i, sep="~")
f = eval(bquote(y ~ .(as.name(i))))
#m0 <- lm(as.formula(f), data=df)
m0 <- lm(f, data=df)
m0z <- arm::standardize(m0)
}
download.file("https://raw.githubusercontent.com/ericpgreen/IEatDataScience/master/labs/lab-w02.Rmd", destfile = "lab-w02c.Rmd")
knitr::opts_chunk$set(echo = TRUE)
sentences <- strsplit(message, '(?<![^!?.])\\s+', perl=TRUE)
phone <- "+254717555555"
message <- "This is a long message. It keeps going on and on. It will definitely be more than 160 characters. See, it just keeps going. It might go on forever and ever. And ever. This is so long that it will probably take 3 or 4 messages to send. Something like that. I wonder if we can make it work?"
sentences <- strsplit(message, '(?<![^!?.])\\s+', perl=TRUE)
nsentences <- length(sentences[[1]])
msg <- sentences[[1]]
s <- 1
m <- 1
while (s <= nsentences) {
sens <- msg[s:nsentences]     # get subset of sentences
charPerSen <- nchar(sens)+1   # count characters per sentence
# plus 1 for space after sentence
cumChar <- cumsum(charPerSen) # get cumulative character count by sentence
i <- sum(cumChar < 155)       # how many sentences from 1 cum less 155?
reply <- paste(sens[1:i],     # string together these sentences
collapse=" ")
assign(paste0("r.", m),       # assign to object name
reply)
s <- s + i
m <- m + 1
}
tot <- m-1
for (r in 1:tot) {
if (r==1) {
r.1 <- paste("Respond",
paste(r, tot, sep="/"),
phone,
r.1)
} else {
x <- paste("Respond",
paste(r, tot, sep="/"),
phone,
paste(r, tot, sep="/"),
get(paste0("r.", r)))
assign(paste0("r.", r), x)
print(x)
}
}
knitr::opts_chunk$set(echo = TRUE)
phone <- "+254717555555"
message <- "This is a long message. It keeps going on and on. It will definitely be more than 160 characters. See, it just keeps going. It might go on forever and ever. And ever. This is so long that it will probably take 3 or 4 messages to send. Something like that. I wonder if we can make it work?"
sentences <- strsplit(message, '(?<![^!?.])\\s+', perl=TRUE)
nsentences <- length(sentences[[1]])
msg <- sentences[[1]]
s <- 1
m <- 1
while (s <= nsentences) {
sens <- msg[s:nsentences]     # get subset of sentences
charPerSen <- nchar(sens)+1   # count characters per sentence
# plus 1 for space after sentence
cumChar <- cumsum(charPerSen) # get cumulative character count by sentence
i <- sum(cumChar < 155)       # how many sentences from 1 cum less 155?
reply <- paste(sens[1:i],     # string together these sentences
collapse=" ")
assign(paste0("r.", m),       # assign to object name
reply)
s <- s + i
m <- m + 1
}
tot <- m-1
for (r in 1:tot) {
if (r==1) {
r.1 <- paste("Respond",
paste(r, tot, sep="/"),
phone,
r.1)
print(r.1)
} else {
x <- paste("Respond",
paste(r, tot, sep="/"),
phone,
paste(r, tot, sep="/"),
get(paste0("r.", r)))
assign(paste0("r.", r), x)
print(x)
}
}
knitr::opts_chunk$set(echo = TRUE)
phone <- "+254717555555"
message <- "This is a long message. It keeps going on and on. It will definitely be more than 160 characters. See, it just keeps going. It might go on forever and ever. And ever. This is so long that it will probably take 3 or 4 messages to send. Something like that. I wonder if we can make it work?"
sentences <- strsplit(message, '(?<![^!?.])\\s+', perl=TRUE)
nsentences <- length(sentences[[1]])
msg <- sentences[[1]]
s <- 1
m <- 1
while (s <= nsentences) {
sens <- msg[s:nsentences]     # get subset of sentences
charPerSen <- nchar(sens)+1   # count characters per sentence
# plus 1 for space after sentence
cumChar <- cumsum(charPerSen) # get cumulative character count by sentence
i <- sum(cumChar < 155)       # how many sentences from 1 cum less 155?
reply <- paste(sens[1:i],     # string together these sentences
collapse=" ")
assign(paste0("r.", m),       # assign to object name
reply)
s <- s + i
m <- m + 1
}
tot <- m-1
for (r in 1:tot) {
if (r==1) {
r.1 <- paste("Respond",
paste(r, tot, sep="/"),
phone,
r.1)
print(r.1)
} else {
x <- paste("Respond",
paste(r, tot, sep="/"),
phone,
get(paste0("r.", r)))
assign(paste0("r.", r), x)
print(x)
}
}
shiny::runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/test')
x <- ""
t <- 1
while(t < 5) {
x <- paste(input$text, x, sep=",")
t <- t + 1
return(x)
x <- ""
t <- 1
while(t < 5) {
x <- paste(input$text, x, sep=",")
t <- t + 1
return(x)
}
x <- ""
t <- 1
while(t < 5) {
x <- paste("test", x, sep=",")
t <- t + 1
return(x)
}
?while
?while
x <- ""
t <- 1
while (t < 5) {
x <- paste("text", x, sep=",")
t <- t + 1
return(x)
}
x <- ""
t <- 1
x
x <- "b"
t <- 1
while (t < 5) {
x <- paste("test", x, sep=",")
t <- t + 1
return(x)
}
x <- "b"
t <- 1
while (t < 5) {
x <- paste("test", x, sep=",")
t <- t + 1
}
x
runApp('Dropbox (Personal)/repos/github/niviCount/test')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/test')
x <- ""
t <- 1
while (t < 5) {
x <- paste("test", x, sep=",")
t <- t + 1
}
x
runApp('Dropbox (Personal)/repos/github/niviCount/test')
x <- ""
t <- 1
while (t < 5) {
x <- paste("help", x, sep=",")
t <- t + 1
}
x
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/test')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
?cat
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
runApp('Dropbox (Personal)/repos/github/niviCount/count')
tot <- 3-1
x <- NULL
for (r in 1:tot) {
x <- c(x,
paste0(paste("Respond",
"help",
paste(r, tot, sep="/"),
get(paste0("r.", r))),
"\\n"))
assign(paste0("r.", r), x)
}
x <- noquote(strsplit(x, "\n"))
return(x)
x <- noquote(strsplit(x, "\n"))
x
noquote(strsplit(x, "\n"))[[1]]
noquote(strsplit(x, "\\n"))[[1]]
x
runApp('Dropbox (Personal)/repos/github/niviCount/count')
rsconnect::setAccountInfo(name='asknivi',
token='AC6F73E46A1282024A8E0E0C6F6ABED8',
secret='AkdhPbWiG45sCphmOUOXb1Hc54nV2+Ha3SAY3Hhw')
Sys.setlocale(locale="en_US.UTF-8")
rsconnect::setAccountInfo(name='asknivi',
token='AC6F73E46A1282024A8E0E0C6F6ABED8',
secret='AkdhPbWiG45sCphmOUOXb1Hc54nV2+Ha3SAY3Hhw')
shiny::runApp('Dropbox (Personal)/repos/github/niviCount/test')
setwd("~/Box Sync/SENSITIVE Folder epg4/Repositories/github/GHR/modules/mod5/AA5-2")
# packages
list.of.packages <- c("plyr", "dplyr", "knitr", "blockTools",
"ggplot2")
new.packages <- list.of.packages[!(list.of.packages %in%
installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library(plyr)
library(dplyr)
library(knitr)
library(blockTools)
library(ggplot2)
# document setttings
knitr::opts_chunk$set(results='hide')
# rounding functions
rd0 <- function(y) sprintf("%.0f", round(y, 0))
rd1 <- function(y) sprintf("%.1f", round(y, 1))
rd2 <- function(y) sprintf("%.2f", round(y, 2))
rd3 <- function(y) sprintf("%.3f", round(y, 3))
set.seed(492)                                      # to make reproducible
N <- 300                                           # sample size of 300
dat <- data.frame(ID=seq(1, N, by=1),
female=sample(0:1,               # indicator for woman
N,
replace=TRUE,
prob=c(.7, .3)),
age=sample(18:35,                # age between 18 and 35
N,
replace=TRUE),
cesdBase=sample(16:60,           # baseline CESD score
N,
replace=TRUE))
head(dat)
dat$rand <- runif(N)                  # create random number between 0 and 1
dat <- dat[order(dat$rand),]          # sort by random number
dat$arm <- c(rep("control",N/2),      # assign first half to control
rep("treatment",N/2))
arm <- group_by(dat, arm)
summarize(arm,
count = n(),
female = mean(female, na.rm = T),
age = mean(age, na.rm = T),
cesdBase = mean(cesdBase, na.rm = T))
# block assignment
block.out <- block(data = dat,
n.tr = 2,
id.vars ="ID",
algorithm="randGreedy",
block.vars = c("female", "age", "cesdBase"),
verbose=TRUE)
assign.out <- assignment(block.out) # reports treatment assignment
# extract assignment details and merge with dat
ID <- as.numeric(as.character(unlist(assign.out$assg[[1]]["Treatment 1"])))
arm2 <- rep("control", length(ID))
datC <- data.frame(cbind(ID, arm2))
ID <- as.numeric(as.character(unlist(assign.out$assg[[1]]["Treatment 2"])))
arm2 <- rep("treatment", length(ID))
datT <- data.frame(cbind(ID, arm2))
datTC <- rbind(datC, datT)
dat <- merge(dat, datTC, by="ID")
head(dat)
dat %>%
group_by(arm) %>%
summarize(count = n(),
female = mean(female, na.rm = T),
age = mean(age, na.rm = T),
cesdBase = mean(cesdBase, na.rm = T))
dat %>%
group_by(arm2) %>%
summarize(count = n(),
female = mean(female, na.rm = T),
age = mean(age, na.rm = T),
cesdBase = mean(cesdBase, na.rm = T))
dat %>%
group_by(arm2) %>%
summarize(count = n(),
female = mean(female, na.rm = T),
age = mean(age, na.rm = T),
cesdBase = mean(cesdBase, na.rm = T))
dat <- dat[order(dat$arm2),]
dat$cesdEnd <- c(sample(12:60,
N/2,
replace=TRUE),
sample(0:25,
N/2,
replace=TRUE))
# plot endline scores by group
ggplot(dat, aes(cesdEnd, fill = arm2)) +
geom_histogram(alpha = 0.5, aes(y = ..density..), position = 'identity')
m1 <- lm(cesdEnd ~ arm2 + female + age + cesdBase,
data=dat)
summary(m1)
N
m1 <- lm(cesdEnd ~ arm2 + female + age + cesdBase,
data=dat)
summary(m1)
# 10% attrition, systematic
set.seed(492)
dat <- dat[order(dat$arm2, dat$cesdBase),]
sam <- sample(0:1,
N/2,
replace=T,
prob=c(0.95, .05))
Nsam <- sum(sam)
miss <- .1*N
dat$att10s <- c(sam,
c(rep(0, 129),
rep(1, miss-Nsam)))
# LOCF for "missing" at endline
dat$cesdEnd.att10s <- ifelse(dat$att10s==1,
dat$cesdBase,
dat$cesdEnd)
# re-run intent to treat analysis
m3 <- lm(cesdEnd.att10s ~ arm2 + female + age + cesdBase,
data=dat)
summary(m3)
dat$treated <- c(rep(0, N/2),
c(rep(1, 120),
rep(0, 30)))
# per protocol
m4 <- lm(cesdEnd ~ arm2 + female + age + cesdBase,
data=dat[(dat$arm2=="control" & dat$treated==0) |
(dat$arm2=="treatment" & dat$treated==1), ])
summary(m4)
# create new variable that reflects treatment received, not assigned
dat$asTreated <- ifelse(dat$arm2=="control", "control",
ifelse(dat$arm2=="treatment" & dat$treated==1, "treatment",
"control"))
# assume that treatment group members not treated would not have improved
dat$cesdEnd[dat$arm2=="treatment" & dat$treated==0] <-
dat$cesdBase[dat$arm2=="treatment" & dat$treated==0]
# per protocol
m5 <- lm(cesdEnd ~ asTreated + female + age + cesdBase,
data=dat)
summary(m5)
