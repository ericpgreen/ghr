---
title: "Session 4.1 Application Activity"
output: html_notebook
---

This R notebook accompanies the [Session 4.1 application activity](http://www.designsandmethods.com/modules/mod4/s4-1/) for [Global Health Research: Designs and Methods](http://www.designsandmethods.com/). To get started, click the "Code" button in the top right corner of the screen and download the `Rmd` file. You have two options for running this file:

1. If you downloaded and installed R and RStudio, you can open this file with RStudio.
2. The easier option is to login to your 'virtual' RStudio environment on Duke's server. Go [here](https://vm-manage.oit.duke.edu/), enter your credentials, and follow the `Docker` link to the option to launch RStudio. Once RStudio is running in your browser, go to the `Files` tab and `Upload` the `Rmd` file. Open it.

## Setup

This first code chunk will check to make sure you have all of the required packages. Put a `#` sign before the word `knitr::opts_chunk$` to turn off (aka, 'comment out') my command to suppress the output.

```{r, message=FALSE}
# packages
  list.of.packages <- c("data.table", "httr", "knitr")
  new.packages <- list.of.packages[!(list.of.packages %in% 
                                     installed.packages()[,"Package"])]
  if(length(new.packages)) install.packages(new.packages)
  library(data.table)
  library(httr)
# document setttings
  knitr::opts_chunk$set(results='hide')  # put a pound sign before this line
# rounding functions
  rd0 <- function(y) sprintf("%.0f", round(y, 0))
  rd1 <- function(y) sprintf("%.1f", round(y, 1))
  rd2 <- function(y) sprintf("%.2f", round(y, 2))
  rd3 <- function(y) sprintf("%.3f", round(y, 3))
```

## Import

Let's start by importing the data. 

```{r, results='hide'}
  response <- GET("https://www.dropbox.com/s/wvm6ykkomwjj37o/1880nc.csv.zip?dl=1",
                  write_disk("1880nc.csv.zip", overwrite = T),
                  progress())
  f <- unzip("1880nc.csv.zip")
  dat <- fread(f[1])
```

If this chunk ran successfully, you will have a dataframe called `dat` in your `Environment` tab.

## Examine the data

Examine the data by running the next chunk with the `head(dat)` command. This will show you the first 6 rows of the dataset. The first several variables are household-level variables, so the values are the same for every member of the household. Starting with gender, the remaining variables are measured for each individual in the household.

```{r}
head(dat)
```

The definitions of key variables are shown in the table below. See [this enumeration form](https://www.nappdata.org/napp-action/source_documents/enum_form_us1880a_tag.xml) to understand what citizens were asked back in 1880. [These instructions](https://www.nappdata.org/napp-action/source_documents/enum_instruct_us1880a_tag.xml) indicate how enumerators were trained to gather this information.

| Variable | Definition |
|:---------|:-----------|
| serial   | a unique identifier for households |
| numperhh | the number of people residing in each household |
| region   | census region |
| statefip | state |
| urban    | urban or rural classification |
| farm     | farm household |
| sex      | gender of person |
| age      | age of person |
| marst    | marital status |
| race     | race |
| nativity | birthplace of self and parents |
| labforce | labor force status |

There are 1,401,478 observations in the dataset, but the official tabulation comes in slightly below this at 1,399,750. Rather than dig through the notes to determine the source of the discrepancy, we'll go with the data file.

![Table 1a](pop2.png)

## Population

Before we jump into samples of the data, let's examine the population. We'll construct an indicator for people are currently or formerly married (`everMarred`). We'll also convert the categorical age variable to numeric.

```{r}
# create a variable for ever married
  dat$everMarried <- ifelse(dat$marst=="Divorced" |
                            dat$marst=="Married, spouse absent" |
                            dat$marst=="Married, spouse present" |
                            dat$marst=="Widowed", 1, 0)

# convert age variable from categorical to numeric
# make some simplifying assumptions about age categories
  dat$ageN <- ifelse(dat$age=="100 (100+ in 1960-1970)", 100,
              ifelse(dat$age=="112 (112+ in the 1980 internal data)", 112,
              ifelse(dat$age=="115 (115+ in the 1990 internal data)", 115,
              ifelse(dat$age=="90 (90+ in 1980 and 1990)", 90,
              ifelse(dat$age=="Less than 1 year old", 0, dat$age)))))
  dat$ageN <- as.numeric(dat$ageN)
  marriedBefore15 <- nrow(dat[dat$everMarried==1 & dat$ageN<15,])
```

Typing the object `marriedBefore15` into the console will return the number of children under 15 years of age who were married (or divorced/widowed) at the time the census was conducted.

Next, let's determine the proportion of single, never married individuals in the population of people at least 15 years old. To make this easy, we'll create a new dataset that is the correct age subset.

```{r}
  dat15 <- dat[dat$ageN>=15,]
  N <- nrow(dat15)
  print(paste0("Denominator is ", N))
  table(dat15$marst)
  singleCt <- table(dat15$marst)[names(table(dat15$marst))=="Never married/single"]
  singleP <- singleCt/N
  singleP
```

For the purpose of this activity, let's take this value, `r singleP`, as the "truth". This is the true proportion of adults (â‰§15 years) that was reported to be single, never married when the census was conducted. 

## Simple Random Sampling

Now let's begin drawing **two** random samples. Use the following code to draw two random samples of 100 observations each and calculate the proportion of single, never married women in each sample. 

```{r}
# sample
  n <- 100

# 100 (a)  
  set.seed(1)
  s100a <- dat15[sample(1:nrow(dat15), n, replace=FALSE),]
  singleCt100a <- table(s100a$marst)[names(table(s100a$marst))=="Never married/single"]
  singleP100a <- singleCt100a/n
  singleP100a

# 100 (b)
  set.seed(2)
  s100b <- dat15[sample(1:nrow(dat15), n, replace=FALSE),]
  singleCt100b <- table(s100b$marst)[names(table(s100b$marst))=="Never married/single"]
  singleP100b <- singleCt100b/n
  singleP100b
```

Now let's draw 10,000 samples. Run the code in the block below and write down your prediction about the shape and center (mean) of the distribution of all 10,000 sample proportions. Once you guess, then run `hist(singleSamples)` and `mean(singleSamples)` in the console and check your prediction.

```{r}
# 10000 samples
  n <- 100
  singleSamples <- NULL
  for (i in 1:10000) {
    # set new seed
    set.seed(i)
    s <- dat15[sample(1:nrow(dat15), n, replace=FALSE),]
    singleCt <- table(s$marst)[names(table(s$marst))=="Never married/single"]
    singleP <- singleCt/n
    singleSamples <- c(singleSamples, singleP)
  }
```

## Sampling Error

Finally, let's examine what happens to sampling error as the sample size increases. The formula for the standard error of a proportion is:

$$
sqrt(p(1-p)/N)
$$
Run the following code and record your results (mean proportion, standard error, margin of error, 95% confidence interval, width of confidence interval). Then change `n <- 100` to `n <- 1000`, run the code again, and note your results. What changed and why? Change the code a final time to `n <- 10000` and note the results.

```{r}
# error
  n <- 100

# create sample
  set.seed(1)
  s <- dat15[sample(1:nrow(dat15), n, replace=FALSE),]
  singleCt <- table(s$marst)[names(table(s$marst))=="Never married/single"]
  singleP <- singleCt/n
  print(paste0("When N is ", n, ": Mean proportion=", rd3(singleP)))

# standard error and 95% confidence intervals
  se <- sqrt((singleP*(1-singleP))/n)         # standard error
  print(paste0("When N is ", n, ": Standard error=", rd3(se)))
  
  me95CI <- 1.96*se                           # margin of error
  print(paste0("When N is ", n, ": Margin of error=", rd3(me95CI)))
  
  CI95l <- singleP - me95CI                   # lower 95% CI
  print(paste0("When N is ", n, ": Lower 95% CI=", rd3(CI95l)))
  
  CI95u <- singleP + me95CI                   # upper 95% CI
  print(paste0("When N is ", n, ": Upper 95% CI=", rd3(CI95u)))
  
  widthCI <- CI95u - CI95l                    # width of CI
  print(paste0("When N is ", n, ": Width of 95% CI=", rd3(widthCI)))
```

Do the same sequence of draws for age (we'll go back to using the entire NC population, not the age restricted one).

```{r}
  ageMPop <- mean(dat$ageN)
```
The mean age of the 1880 NC population was `r rd1(ageMPop)`.

```{r}
# error
  n <- 100

# create sample
  set.seed(1)
  s <- dat[sample(1:nrow(dat), n, replace=FALSE),]
  ageM <- mean(s$ageN)
  print(paste0("When N is ", n, ": Mean age=", rd2(ageM)))

# standard error and 95% confidence intervals
  se <- sd(s$ageN)/sqrt(n)                    # standard error
  print(paste0("When N is ", n, ": Standard error=", rd2(se)))
  
  me95CI <- 1.96*se                           # margin of error
  print(paste0("When N is ", n, ": Margin of error=", rd2(me95CI)))
  
  CI95l <- ageM - me95CI                   # lower 95% CI
  print(paste0("When N is ", n, ": Lower 95% CI=", rd2(CI95l)))
  
  CI95u <- ageM + me95CI                   # upper 95% CI
  print(paste0("When N is ", n, ": Upper 95% CI=", rd2(CI95u)))
  
  widthCI <- CI95u - CI95l                    # width of CI
  print(paste0("When N is ", n, ": Width of 95% CI=", rd2(widthCI)))
```